# 方案设计 #

[TOC]

## 编排模型 ##

有向无环图，节点代表一个步骤。

<img src="https://static-1256056882.cos.ap-guangzhou.myqcloud.com/seven%2Fjobflow.DAG.png">

## 编排语法 ##

见于 [使用手册](/doc/manual.md)

## 编排通知机制 ##

### 下发状态 ###

见于 [数据设计](/doc/model.md)【状态消息】章节

### 上报结果 ###

见于 [接口文档](/doc/interface.md)【上报结果】章节

## 编排引擎架构 ##

<img src="https://static-1256056882.cos.ap-guangzhou.myqcloud.com/seven/jobflow.frame.png">

- OSS : API接口。负责编排的创建、查询、触发任务、任务状态等
- DB : 存储编排、历次触发任务、任务进度、定时触发策略等
- MQ : 消息队列
- Dispatcher : 状态流转调度器
- Timer : 定时触发器
- ZK : 策略变更事件

## 编排运行机制 ##

### 状态机 ###

先解释一下，MQ中有两类消息 :

| 消息 | 生产者 | 消费者 | 描述 |
| ---- | ---- | ---- | ---- |
| 调度命令 | OSS | Dispatcher | 哪个任务要被调度（希望更新一下它的状态流转） |
| 状态流转 | Dispatcher | 业务方Consumer上的Agent | 编排的步骤进度流转 |

如此，对编排运行的状态机的维护，就从OSS抽离出来，专门让Dispatcher负责。

从编排的生命周期来看，分以下阶段来具体论述模块间的调用关系

**创建阶段**

- 【OSS】将编排写入【DB】

**手动触发阶段**

- 【OSS】创建一个新任务，写入【DB】
- 【OSS】封装一个 **"调度命令"的消息**（表示哪个任务将要被调度），扔给【MQ】

**定时触发阶段**

- 【Timer】启动后，调用【OSS】接口，拉取定时触发策略，缓存到本地
- 当既有编排的定时触发策略被更新时，【OSS】会将策略写入【DB】，并在【ZK】中对应节点上触发事件
- 【Timer】监听【ZK】中的事件，再次调用【OSS】接口，以更新自己本地内存中的策略
- 【Timer】根据本地缓存的策略，当需要触发某个编排时，调用【OSS】接口来完成

**任务执行阶段**

- 【Dispatcher】从【MQ】拿到【调度命令】，从中得到 taskId、编排ID
- 【Dispatcher】调用【OSS】接口，获取 任务进度 + 编排DAG
- 【Dispatcher】根据DAG拓扑关系，计算现在应该执行哪些节点，并封装 **"状态流转"的消息**，扔给【MQ】
- 业务方消费者，会集成我们提供的【Agent】，它会订阅自己关注的 **"状态流转"的消息**
- 执行完业务逻辑后，【Agent】调用【OSS】接口上报 本步骤的结果
- 【OSS】更新任务进度到【DB】，并再次封装一个 **"调度命令"的消息**（taskId、编排ID），扔给【MQ】，这就循环到了第一步

### 异常处理 ###
#### 中断 ####
#### 中断恢复 ####
#### 失败继续 ####

## 编排管理 ##

### 历史任务 ###
### 定时触发 ###